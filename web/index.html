<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CN Snowmelt</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: 0; }

    .panel-stack{
      position:absolute;
      right:14px;
      bottom:14px;
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:40;
    }

    .panel-link{
      width:340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .panel-link a{
      color:#0b57d0;
      text-decoration:none;
      font-weight:600;
      font-size:14px;
    }

    .panel-link a:hover{
      text-decoration:underline;
    }

    .panel {
      width: 340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 12px 12px 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
    }
    .panel h3 { margin: 0 0 2px 0; font-size: 16px; line-height: 1.2; }
    .sub { font-size: 13px; color: #333; margin-bottom: 10px; }

    .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .row label { font-size: 14px; }

    .pickrow { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin: 8px 0 10px 0; }
    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.95);
      font-size: 13px;
    }
    select:disabled { opacity: 0.5; }

    .sliderrow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    input[type="range"] { width: 190px; }

    .legend { margin-top: 10px; border-top: 1px solid rgba(0,0,0,0.10); padding-top: 10px; }
    .legend-title { font-size: 13px; font-weight: 600; margin: 0 0 6px 0; }
    .legend-grid { display: grid; grid-template-columns: 20px 1fr; gap: 6px 10px; }
    .swatch { width: 20px; height: 12px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.12); }
    .legend-label { font-size: 12px; color: #222; }

    .err { margin-top: 8px; font-size: 12px; color: #b00020; display: none; white-space: pre-wrap; }

    .cursor-readout {
      position: absolute;
      pointer-events: none;
      z-index: 50;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      padding: 4px 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      transform: translate(10px, 10px);
      display: none;
      white-space: nowrap;
    }
  </style>

</head>
<body>
  <div id="map"></div>
  <div id="cursorReadout" class="cursor-readout"></div>

  <div class="panel-stack">
    <div class="panel-link">
      <a href="https://accuweather.atlassian.net/wiki/spaces/AO/pages/3596288537/Snowmelt" id="confluenceLink" target="_blank" rel="noopener">Snowmelt Confluence</a>
    </div>

    <div class="panel" id="mainPanel">
      <h3>CN Snowmelt</h3>
      <div class="sub" id="subtitle">Loading…</div>

      <div class="pickrow">
        <select id="yearSel"></select>
        <select id="monthSel"></select>
        <select id="daySel"></select>
      </div>

      <div class="row">
        <input type="radio" name="hours" id="h24" value="24" checked>
        <label for="h24">24 Hour Snowmelt</label>
      </div>
      <div class="row">
        <input type="radio" name="hours" id="h72" value="72">
        <label for="h72">72 Hour Snowmelt</label>
      </div>

      <div class="sliderrow">
        <div style="font-size:13px;">Opacity</div>
        <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.80" />
        <div id="opv" style="font-size:12px;color:#333;width:40px;text-align:right;"></div>
      </div>

      <div class="legend">
        <div class="legend-title" id="legendTitle">Inches of water equivalent</div>
        <div class="legend-grid" id="legendGrid"></div>
      </div>

      <div class="err" id="err"></div>
    </div>
  </div>
<script src="/config.js"></script>
<script>
(function () {
  const errBox=document.getElementById("err"),subtitle=document.getElementById("subtitle"),yearSel=document.getElementById("yearSel"),monthSel=document.getElementById("monthSel"),daySel=document.getElementById("daySel"),legendGrid=document.getElementById("legendGrid"),OPACITY=document.getElementById("opacity"),OPV=document.getElementById("opv"),cursorEl=document.getElementById("cursorReadout");

  const DOM="zz";
  const TRACE_INCHES=0.02;
  const ALPHA_GATE=false;

  const MIN_ZOOM_FOR_READOUT=9;
  const CURSOR_ZMIN=9;
  const PREFETCH_ZMIN=9;

  const INITIAL_BOUNDS=[[-130.359201,29.915607],[-63.228204,60.840431]];

  let readoutsEnabled=false,lastKey="";
  const GRID_RESOLUTION = 12;
  const GRID_EXPAND_FRAC = 0.35;
  const GRID_TIMEOUT_MS = 6000;
  const POINT_TIMEOUT_MS = 2500;
  
  let gridAbort = null;
  let gridFetchInProgress = false;
  
  function fetchWithTimeout(url, opts, ms){
    const timeoutCtrl = new AbortController();
    const t = setTimeout(() => timeoutCtrl.abort("timeout"), ms);
  
    const userSignal = opts && opts.signal ? opts.signal : null;
  
    let signal = timeoutCtrl.signal;
    if (userSignal) {
      const combo = new AbortController();
      const onAbort = () => combo.abort("aborted");
      userSignal.addEventListener("abort", onAbort, { once: true });
      timeoutCtrl.signal.addEventListener("abort", onAbort, { once: true });
      signal = combo.signal;
    }
  
    const merged = Object.assign({}, opts || {}, { signal });
    return fetch(url, merged).finally(() => clearTimeout(t));
  }

  function clampLat(lat){ return Math.max(-85, Math.min(85, lat)); }

  function showErr(msg){errBox.style.display="block";errBox.textContent=msg}
  function z2(n){return(n<10?"0":"")+n}

  const token=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.MAPBOX_TOKEN)||"";
  if(!token){showErr("Missing MAPBOX_TOKEN. Check /config.js and server environment.");return}
  mapboxgl.accessToken=token;

  const map=new mapboxgl.Map({
    container:"map",
    style:"mapbox://styles/mapbox/satellite-streets-v12",
    bounds: INITIAL_BOUNDS,
    fitBoundsOptions:{padding:40,duration:0,maxZoom:7}
  });

  if(typeof map.isPitching!=="function")map.isPitching=()=>false;
  if(typeof map.isRotating!=="function")map.isRotating=()=>false;

  const VALUE_BASE=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.VALUE_BASE)||window.location.origin;
  // ===== HF TILE CONFIG (prevents ReferenceError + allows direct dataset reads) =====
  const USE_HF_TILES = !!((window.__SNODAS_CONFIG__ && window.__SNODAS_CONFIG__.USE_HF_TILES) || false);

  const HF_TILE_BASE =
    (window.__SNODAS_CONFIG__ && window.__SNODAS_CONFIG__.HF_TILE_BASE) ||
    (window.__SNODAS_CONFIG__ && window.__SNODAS_CONFIG__.HF_DATASET_REPO
      ? ("https://huggingface.co/datasets/" + window.__SNODAS_CONFIG__.HF_DATASET_REPO + "/resolve/main")
      : "");

  function hfTileUrlTemplate(ymd, hours, dom){
    dom = (dom || "zz").toLowerCase();
    return HF_TILE_BASE + `/tilecache/bydate_${dom}_h${hours}_${ymd}_z{z}_{x}_{y}.png`;
  }

  const CN_LINE_GLOW="cn_tracks_src_line_glow",CN_LINE="cn_tracks_src_line";
  const LAYER_ID="melt_layer",SRC_ID="melt_src";

  function tracksReady(){return !!(map.getLayer(CN_LINE)||map.getLayer(CN_LINE_GLOW))}

  const TRACK_CORRIDOR_MILES = 8;
  const TRACK_CORRIDOR_PX_CAP = 90;
  
  function milesToPixels(miles, latDeg, zoom){
    const meters = miles * 1609.344;
    const lat = latDeg * Math.PI / 180;
    const metersPerPixel = 156543.03392 * Math.cos(lat) / Math.pow(2, zoom);
    if (!isFinite(metersPerPixel) || metersPerPixel <= 0) return TRACK_CORRIDOR_PX_CAP;
    return meters / metersPerPixel;
  }
  
  function nearTrack(point, lngLat){
    const layers = [];
    if (map.getLayer(CN_LINE)) layers.push(CN_LINE);
    if (map.getLayer(CN_LINE_GLOW)) layers.push(CN_LINE_GLOW);
    if (!layers.length) return false;
  
    const z = map.getZoom();
    const rRaw = milesToPixels(TRACK_CORRIDOR_MILES, lngLat.lat, z);
    const r = Math.max(6, Math.min(TRACK_CORRIDOR_PX_CAP, Math.round(rRaw)));
  
    const bbox = [
      [point.x - r, point.y - r],
      [point.x + r, point.y + r]
    ];
  
    const feats = map.queryRenderedFeatures(bbox, { layers });
    return !!(feats && feats.length);
  }

  function muteRoads(map){
    const style=map.getStyle(); if(!style||!style.layers)return;
    const roadLike=l=>{const id=(l.id||"").toLowerCase(),sl=(l["source-layer"]||"").toLowerCase();return id.includes("road")||id.includes("street")||id.includes("highway")||id.includes("bridge")||id.includes("tunnel")||id.includes("motorway")||sl.includes("road")||sl.includes("street")||sl.includes("transportation")};
    for(const l of style.layers){
      if(!roadLike(l))continue;
      if(l.type==="line"){
        if(map.getPaintProperty(l.id,"line-color")!=null)map.setPaintProperty(l.id,"line-color","#c7c7c7");
        if(map.getPaintProperty(l.id,"line-opacity")!=null)map.setPaintProperty(l.id,"line-opacity",0.40);
        if(map.getPaintProperty(l.id,"line-width")!=null){const w=map.getPaintProperty(l.id,"line-width");if(typeof w==="number")map.setPaintProperty(l.id,"line-width",Math.max(0.5,w*0.8))}
      }
      if(l.type==="fill"){
        if(map.getPaintProperty(l.id,"fill-color")!=null)map.setPaintProperty(l.id,"fill-color","#d0d0d0");
        if(map.getPaintProperty(l.id,"fill-opacity")!=null)map.setPaintProperty(l.id,"fill-opacity",0.20);
      }
    }
  }

  function lon2tile(lon,z){return Math.floor(((lon+180)/360)*(1<<z))}
  function lat2tile(lat,z){const r=lat*Math.PI/180,n=Math.log(Math.tan(Math.PI/4+r/2));return Math.floor((1-n/Math.PI)/2*(1<<z))}
  function clamp(n,a,b){return Math.max(a,Math.min(b,n))}
  function tileRangeForBounds(b,z){
    const w=b.getWest(),s=b.getSouth(),e=b.getEast(),n=b.getNorth(),max=(1<<z)-1;
    let x0=lon2tile(w,z),x1=lon2tile(e,z),y0=lat2tile(n,z),y1=lat2tile(s,z);
    x0=clamp(x0,0,max);x1=clamp(x1,0,max);y0=clamp(y0,0,max);y1=clamp(y1,0,max);
    const xmin=Math.min(x0,x1),xmax=Math.max(x0,x1),ymin=Math.min(y0,y1),ymax=Math.max(y0,y1);
    return{xmin,xmax,ymin,ymax}
  }

  function makeQueue(limit){
    let active=0;const q=[];
    const run=()=>{while(active<limit&&q.length){const fn=q.shift();active++;Promise.resolve().then(fn).catch(()=>{}).finally(()=>{active--;run()})}};
    const push=fn=>{q.push(fn);run()};
    push.clear=()=>{q.length=0};
    return push
  }

  function tileUrl(z,x,y,ymd,hours){
    if (USE_HF_TILES && HF_TILE_BASE) {
      return hfTileUrlTemplate(ymd, hours, DOM)
        .replace("{z}", String(z))
        .replace("{x}", String(x))
        .replace("{y}", String(y));
    }
    return `/tiles/forecast/by_date/${z}/${x}/${y}.png?date_yyyymmdd=${encodeURIComponent(ymd)}&hours=${encodeURIComponent(hours)}&dom=${encodeURIComponent(DOM)}`;
  }



  const prefetchPush=makeQueue(10);
  const prefetched=new Set();

  function prefetchViewportTiles(){
    if(map.getZoom()<PREFETCH_ZMIN)return;
    const ymd=selectedDateYMD();
    if(!ymd)return;
    const hours=getHours();
    const z0=Math.max(0,Math.floor(map.getZoom()));
    const maxZ=Math.min(12,z0+3);
    const b=map.getBounds();
    for(let z=z0+1;z<=maxZ;z++){
      const r=tileRangeForBounds(b,z);
      for(let x=r.xmin;x<=r.xmax;x++)for(let y=r.ymin;y<=r.ymax;y++){
        const u=tileUrl(z,x,y,ymd,hours);
        if(prefetched.has(u))continue;
        prefetched.add(u);
        prefetchPush(()=>fetch(u,{cache:"force-cache"}));
      }
    }
  }

  function debounce(fn,ms){let t=0;return()=>{clearTimeout(t);t=setTimeout(fn,ms)}}
  const prefetchDebounced=debounce(prefetchViewportTiles,250);

  map.on("load",()=>muteRoads(map));
  map.on("styledata",()=>muteRoads(map));

  const LEGENDS={
    "24":{
      colors:["#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00","#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"],
      labels:["0.00 to trace","trace to 0.02","0.02 to 0.04","0.04 to 0.08","0.08 to 0.12","0.12 to 0.16","0.16 to 0.20","0.20 to 0.39","0.39 to 0.59","0.59 to 0.79","0.79 to 0.98","0.98 to 1.4","1.4 to 2.0","2.0 to 3.0","3.0 to 4.0","4.0 to 5.0","> 5.0"]
    },
    "72":{
      colors:["#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00","#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"],
      labels:["0.00 to trace","trace to 0.04","0.04 to 0.08","0.08 to 0.16","0.16 to 0.24","0.24 to 0.31","0.31 to 0.39","0.39 to 0.79","0.79 to 1.4","1.4 to 2.0","2.0 to 3.0","3.0 to 3.9","3.9 to 5.0","5.0 to 6.5","6.5 to 8.0","8.0 to 9.8","> 9.8"]
    }
  };

  function renderLegend(hours){
    const L=LEGENDS[String(hours)]||LEGENDS["24"];
    legendGrid.innerHTML="";
    for(let i=0;i<L.colors.length;i++){
      const sw=document.createElement("div");sw.className="swatch";sw.style.background=L.colors[i];
      const lb=document.createElement("div");lb.className="legend-label";lb.textContent=L.labels[i]||"";
      legendGrid.appendChild(sw);legendGrid.appendChild(lb);
    }
  }

  function getHours(){const el=document.querySelector('input[name="hours"]:checked');return el?parseInt(el.value,10):24}
  function selectedDateYMD(){const y=yearSel.value,m=monthSel.value,d=daySel.value; if(!y||!m||!d)return null; return`${y}${m}${d}`}
  function subtitleText(yyyymmdd,hours){const y=yyyymmdd.slice(0,4),m=yyyymmdd.slice(4,6),d=yyyymmdd.slice(6,8);return`${hours} Hour snowmelt ending on ${y}-${m}-${d} 05Z`}

  async function addCnTracksVectorTiles(){
    const SRC = "cn_tracks_vt";
    const CN_MAX_ZOOM = 7;

    if (map.getSource(SRC)) return;

    map.addSource(SRC, {
      type: "vector",
      tiles: [`${VALUE_BASE}/cn_tiles/{z}/{x}/{y}.pbf`],
      minzoom: 0,
      maxzoom: 7,
      bounds: [-170, 29, -63, 90]
    });

    map.addLayer({
      id: CN_LINE_GLOW,
      type: "line",
      source: SRC,
      "source-layer": "cn_tracks",
      minzoom: 0,
      maxzoom: 24,
      layout: { "line-join": "round", "line-cap": "round" },
      paint: {
        "line-color": "#ff0000",
        "line-opacity": 0.85,
        "line-blur": 2.0,
        "line-width": ["interpolate", ["linear"], ["zoom"], 4, 2.0, 6, 4.0, 8, 6.0, 10, 8.0, 12, 10.0, 14, 12.0]
      }
    });

    map.addLayer({
      id: CN_LINE,
      type: "line",
      source: SRC,
      "source-layer": "cn_tracks",
      minzoom: 0,
      maxzoom: 24,
      layout: { "line-join": "round", "line-cap": "round" },
      paint: {
        "line-color": "#ffffff",
        "line-opacity": 0.95,
        "line-width": ["interpolate", ["linear"], ["zoom"], 4, 0.8, 6, 1.6, 8, 2.4, 10, 3.2, 12, 4.0, 14, 4.8]
      }
    });
  }

  function setOpacity(v){OPV.textContent=v.toFixed(2);if(map.getLayer(LAYER_ID))map.setPaintProperty(LAYER_ID,"raster-opacity",v)}

  let selGen=0;

  function setTilesForSelection(){
    const ymd = selectedDateYMD();
    const hours = getHours();
    if(!ymd) return;
    
    selGen++;
    subtitle.textContent = subtitleText(ymd, hours);
    renderLegend(hours);
    
    cursorEl.style.display = "none";
    lastKey = "";
    
    const tiles = [
      (USE_HF_TILES && HF_TILE_BASE)
        ? hfTileUrlTemplate(ymd, hours, DOM)
        : `/tiles/forecast/by_date/{z}/{x}/{y}.png?date_yyyymmdd=${encodeURIComponent(ymd)}&hours=${encodeURIComponent(hours)}&dom=${encodeURIComponent(DOM)}`
    ];

    // Remove and re-add to force tile refresh
    if (map.getLayer(LAYER_ID)) {
      map.removeLayer(LAYER_ID);
    }
    if (map.getSource(SRC_ID)) {
      map.removeSource(SRC_ID);
    }
    
    // Small delay to ensure removal completes
    setTimeout(() => {
      map.addSource(SRC_ID, {
        type: "raster",
        tiles: tiles,
        tileSize: 256,
        maxzoom: 12,
        bounds: [-170, 29, -40, 90]
      });
      
      map.addLayer({
        id: LAYER_ID,
        type: "raster",
        source: SRC_ID,
        paint: {
          "raster-opacity": parseFloat(OPACITY.value)
        }
      });
      
      if (map.getLayer(CN_LINE_GLOW)) {
        map.moveLayer(LAYER_ID, CN_LINE_GLOW);
      }
    }, 50);
    
    prefetched.clear();
    prefetchViewportTiles();
  }

  function setSelectOptions(sel,options,value,disabledSet){
    sel.innerHTML="";
    for(const opt of options){
      const o=document.createElement("option");
      o.value=opt.value;o.textContent=opt.label;
      if(disabledSet&&disabledSet.has(opt.value))o.disabled=true;
      sel.appendChild(o);
    }
    if(value)sel.value=value;
  }

  function monthName(m){const names=["January","February","March","April","May","June","July","August","September","October","November","December"];return names[parseInt(m,10)-1]||m}

  let available=[],availableSet=new Set();

  function recomputeDayOptions(){
    const y=yearSel.value,m=monthSel.value; if(!y||!m)return;
    const days=[],disabled=new Set(),monthDays=31;
    for(let dd=1;dd<=monthDays;dd++){
      const d2=z2(dd),ymd=`${y}${m}${d2}`;
      days.push({value:d2,label:String(dd)});
      if(!availableSet.has(ymd))disabled.add(d2);
    }
    const prev=daySel.value;
    setSelectOptions(daySel,days,prev,disabled);
    if(daySel.options[daySel.selectedIndex]&&daySel.options[daySel.selectedIndex].disabled){
      const firstEnabled=Array.from(daySel.options).find(o=>!o.disabled);
      if(firstEnabled)daySel.value=firstEnabled.value;
    }
  }

  function recomputeMonthOptions(){
    const y=yearSel.value,months=[],disabled=new Set();
    for(let mm=1;mm<=12;mm++){
      const m2=z2(mm);
      months.push({value:m2,label:monthName(m2)});
      const hasAny=available.some(d=>d.startsWith(`${y}${m2}`));
      if(!hasAny)disabled.add(m2);
    }
    const prev=monthSel.value;
    setSelectOptions(monthSel,months,prev,disabled);
    if(monthSel.options[monthSel.selectedIndex]&&monthSel.options[monthSel.selectedIndex].disabled){
      const firstEnabled=Array.from(monthSel.options).find(o=>!o.disabled);
      if(firstEnabled)monthSel.value=firstEnabled.value;
    }
  }

  function initSelectorsFromAvailable(){
    availableSet=new Set(available);
    const years=Array.from(new Set(available.map(d=>d.slice(0,4)))).sort();
    setSelectOptions(yearSel,years.map(y=>({value:y,label:y})),years[years.length-1]);
    recomputeMonthOptions();recomputeDayOptions();
    const latest=available[available.length-1];
    if(latest){
      yearSel.value=latest.slice(0,4);
      recomputeMonthOptions();
      monthSel.value=latest.slice(4,6);
      recomputeDayOptions();
      daySel.value=latest.slice(6,8);
    }
  }

  async function loadAvailable(){
    const r=await fetch(`${VALUE_BASE}/forecast/available_days?lookback_days=5`,{cache:"no-store"});
    if(!r.ok)throw new Error(`forecast/available_days -> HTTP ${r.status}`);
    const j=await r.json();
    available=(j&&j.available_dates?j.available_dates:[]).slice();
    return j;
  }

  function showCursorReadout(px,py,text){
    cursorEl.style.left=px+"px";
    cursorEl.style.top=py+"px";
    if(!text){cursorEl.style.display="none";return}
    cursorEl.textContent=text;
    cursorEl.style.display="block";
  }

  // ========== VIEWPORT GRID PREFETCH SYSTEM ==========
  let viewportGrid = null;
  let lastGridBounds = null;

  let lastGridKey = "";
  let pendingCursorUpdate = null;
  let hoverSeq = 0;               // already exists later in your file; move it up and use it here
  let lastHoverKey = "";          // prevents re-running for tiny mouse jitter
  const HOVER_PIXEL_EPS = 2;      // ignore 1px jitter

  function shouldRefetchGrid() {
    if (!viewportGrid) return true;
    
    const ymd = selectedDateYMD();
    const hours = getHours();
    const dateKey = `${ymd}|${hours}`;
    
    if (lastGridKey !== dateKey) return true;
    
    if (!lastGridBounds) return true;
    
    const currentBounds = map.getBounds();
    const cw = currentBounds.getWest();
    const cs = currentBounds.getSouth();
    const ce = currentBounds.getEast();
    const cn = currentBounds.getNorth();
    
    const gw = lastGridBounds[0];
    const gs = lastGridBounds[1];
    const ge = lastGridBounds[2];
    const gn = lastGridBounds[3];
    
    const lonBuffer = (ge - gw) * 0.2;
    const latBuffer = (gn - gs) * 0.2;
    
    if (cw < gw + lonBuffer || ce > ge - lonBuffer || 
        cs < gs + latBuffer || cn > gn - latBuffer) {
      return true;
    }
    
    return false;
  }

  async function fetchViewportGrid(){
    const ymd = selectedDateYMD();
    if (!ymd) return;
  
    const hours = getHours();
  
    if (gridAbort) { try { gridAbort.abort(); } catch {} }
    gridAbort = new AbortController();
  
    gridFetchInProgress = true;
  
    try{
      const b = map.getBounds();
      const c = b.getCenter();
      const lonSpan = (b.getEast() - b.getWest());
      const latSpan = (b.getNorth() - b.getSouth());
  
      const expandLon = lonSpan * GRID_EXPAND_FRAC;
      const expandLat = latSpan * GRID_EXPAND_FRAC;
  
      const expandedBounds = [
        c.lng - lonSpan/2 - expandLon,
        clampLat(c.lat - latSpan/2 - expandLat),
        c.lng + lonSpan/2 + expandLon,
        clampLat(c.lat + latSpan/2 + expandLat),
      ];
  
      const payload = {
        date_yyyymmdd: ymd,
        hours,
        dom: DOM,
        bounds: expandedBounds,
        resolution: GRID_RESOLUTION
      };
  
      const r = await fetchWithTimeout(`${VALUE_BASE}/value/forecast/viewport_grid`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
        cache: "no-store",
        signal: gridAbort.signal
      }, GRID_TIMEOUT_MS);
  
      if (!r.ok) throw new Error(`grid http ${r.status}`);
  
      const data = await r.json();
  
      viewportGrid = data;
      lastGridBounds = data.bounds;
      lastGridKey = `${ymd}|${hours}`;
  
    if (pendingCursorUpdate) {
      const pu = pendingCursorUpdate;
      // only refresh if it’s still the latest hover
      if (pu.seq === hoverSeq) {
        // call update again so it can use the grid immediately
        updateCursorReadout({lng: pu.lngLat.lng, lat: pu.lngLat.lat}, {x: pu.point.x, y: pu.point.y}, pu.seq);
      }
    }
    } catch(e){
      // If aborted/timeout, just swallow; cursor fallback handles it.
      // But do not leave pendingCursorUpdate stuck.
      if (pendingCursorUpdate) {
        const { point } = pendingCursorUpdate;
        // clear “Loading…” if we can’t service it
        showCursorReadout(point.x, point.y, "");
        pendingCursorUpdate = null;
      }
    } finally{
      gridFetchInProgress = false;
    }
  }
  async function fetchPointValueFast(ymd, hours, lon, lat){
    const payload = { date_yyyymmdd: ymd, hours, dom: DOM, pts: [[lon, lat]] };
  
    try{
      const r = await fetchWithTimeout(`${VALUE_BASE}/value/forecast/by_date_batch`, {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(payload),
        cache: "no-store"
      }, POINT_TIMEOUT_MS);
  
      if (!r.ok) return null;
  
      const j = await r.json();
      const v = (j && j.values && j.values[0]) ? j.values[0] : null;
  
      const inches =
        (v && typeof v.inches_1dp === "number") ? v.inches_1dp :
        (v && typeof v.inches === "number") ? v.inches :
        null;
  
      return (inches == null) ? null : inches;
    } catch {
      return null;
    }
  }

  function interpolateFromGrid(lon, lat) {
    if (!viewportGrid || !viewportGrid.grid) return null;
    
    const {lons, lats, grid} = viewportGrid;
    
    let lonIdx = -1, latIdx = -1;
    
    for (let i = 0; i < lons.length - 1; i++) {
      if (lon >= lons[i] && lon <= lons[i + 1]) {
        lonIdx = i;
        break;
      }
    }
    
    for (let i = 0; i < lats.length - 1; i++) {
      if (lat >= lats[i] && lat <= lats[i + 1]) {
        latIdx = i;
        break;
      }
    }
    
    if (lonIdx === -1 || latIdx === -1) return null;
    
    const v00 = grid[latIdx][lonIdx];
    const v10 = grid[latIdx][lonIdx + 1];
    const v01 = grid[latIdx + 1][lonIdx];
    const v11 = grid[latIdx + 1][lonIdx + 1];
    
    if (v00 === null && v10 === null && v01 === null && v11 === null) {
      return null;
    }
    
    if (v00 === null || v10 === null || v01 === null || v11 === null) {
      return v00 ?? v10 ?? v01 ?? v11;
    }
    
    const lonFrac = (lon - lons[lonIdx]) / (lons[lonIdx + 1] - lons[lonIdx]);
    const latFrac = (lat - lats[latIdx]) / (lats[latIdx + 1] - lats[latIdx]);
    
    const v0 = v00 * (1 - lonFrac) + v10 * lonFrac;
    const v1 = v01 * (1 - lonFrac) + v11 * lonFrac;
    const value = v0 * (1 - latFrac) + v1 * latFrac;
    
    return value;
  }

   async function updateCursorReadout(lngLat, point, seq){
    // If a newer hover happened, stop immediately
    if (seq !== hoverSeq) return;
  
    if (map.getZoom() < CURSOR_ZMIN) { showCursorReadout(point.x, point.y, ""); return; }
    if (!tracksReady()) { showCursorReadout(point.x, point.y, ""); return; }
    if (!nearTrack(point, lngLat)) { showCursorReadout(point.x, point.y, ""); return; }
  
    const ymd = selectedDateYMD();
    if (!ymd) { showCursorReadout(point.x, point.y, ""); return; }
    const hours = getHours();
  
    // Build a stable request key: quantize lon/lat a bit so tiny moves don’t create new requests
    const qLon = Math.round(lngLat.lng * 10000) / 10000; // ~11m at equator, fine for readout
    const qLat = Math.round(lngLat.lat * 10000) / 10000;
    const reqKey = `${ymd}|${hours}|${qLon}|${qLat}`;
  
    // If we already have a fresh grid that still covers the viewport, use it immediately
    if (viewportGrid && !shouldRefetchGrid()) {
      const v = interpolateFromGrid(lngLat.lng, lngLat.lat);
      if (seq !== hoverSeq) return;
  
      if (v != null && v > TRACE_INCHES) {
        showCursorReadout(point.x, point.y, v.toFixed(1) + " in");
        return;
      }
      showCursorReadout(point.x, point.y, "");
      return;
    }
  
    // Show loading, but bind it to THIS request key + seq
    showCursorReadout(point.x, point.y, "Loading...");
    pendingCursorUpdate = { seq, reqKey, lngLat: {lng: lngLat.lng, lat: lngLat.lat}, point: {x: point.x, y: point.y} };
  
    // Kick off a grid refresh in background (don’t await)
    if (!gridFetchInProgress) fetchViewportGrid();
  
    // Fast fallback point request for responsiveness
    const inches = await fetchPointValueFast(ymd, hours, lngLat.lng, lngLat.lat);
  
    // If user moved since we started, don’t overwrite
    if (seq !== hoverSeq) return;
    if (!pendingCursorUpdate || pendingCursorUpdate.reqKey !== reqKey || pendingCursorUpdate.seq !== seq) return;
  
    pendingCursorUpdate = null;
  
    if (inches != null && inches > TRACE_INCHES) {
      showCursorReadout(point.x, point.y, Number(inches).toFixed(1) + " in");
    } else {
      showCursorReadout(point.x, point.y, "");
    }
  }
  

  const debouncedGridFetch = debounce(fetchViewportGrid, 500);

  function onSelectionChange() {
    viewportGrid = null;
    lastGridBounds = null;
    lastGridKey = "";
    pendingCursorUpdate = null;
    fetchViewportGrid();
  }

  function shouldReadout(){
    const z=map.getZoom();
    const ok=z>=MIN_ZOOM_FOR_READOUT;
    if(!ok&&readoutsEnabled){
      readoutsEnabled=false;
      lastKey="";
      showCursorReadout(0,0,"");
    } else if(ok&&!readoutsEnabled){
      readoutsEnabled=true;
    }
    return ok;
  }

  map.on("mousemove", (e) => {
    if (cursorEl.style.display !== "none") {
      cursorEl.style.left = e.point.x + "px";
      cursorEl.style.top = e.point.y + "px";
    }
  
    if (!shouldReadout()) return;
    if (!tracksReady()) return;
  
    // Simple jitter gate so we don’t spam async calls on micro-moves
    const px = Math.round(e.point.x);
    const py = Math.round(e.point.y);
    const ymd = selectedDateYMD();
    const hours = getHours();
    if (!ymd) return;
  
    const key = `${ymd}|${hours}|${px}|${py}`;
    if (lastHoverKey) {
      const parts = lastHoverKey.split("|");
      const opx = parseInt(parts[2], 10);
      const opy = parseInt(parts[3], 10);
      if (Math.abs(px - opx) <= HOVER_PIXEL_EPS && Math.abs(py - opy) <= HOVER_PIXEL_EPS) {
        return;
      }
    }
    lastHoverKey = key;
  
    const mySeq = ++hoverSeq;
    updateCursorReadout(e.lngLat, e.point, mySeq);
  });

  map.on("mouseout", () => {
    showCursorReadout(0, 0, "");
    pendingCursorUpdate = null;
  });

  map.on("moveend", () => {
    debouncedGridFetch();
  });

  map.on("zoomend", () => {
    shouldReadout();
    if(map.getZoom()<CURSOR_ZMIN){lastKey="";showCursorReadout(0,0,"")}
    debouncedGridFetch();
    prefetchDebounced();
  });

  map.on("error", (e) => {
    const err = e.error;
    if (err && err.message && err.message.includes("404")) {
      console.warn("Tile not found:", err);
      return;
    }
    showErr("Map error:\n" + (err ? err.message : String(e)));
  });

  map.on("load",async()=>{
    try{
      renderLegend(24);

      const availPromise=loadAvailable();
      await addCnTracksVectorTiles();

      await availPromise;
      if(!available.length){showErr("No available days returned from /forecast/available_days");return}

      initSelectorsFromAvailable();
      setTilesForSelection();
      prefetchViewportTiles();
      setOpacity(parseFloat(OPACITY.value));
      shouldReadout();
      onSelectionChange();
    } catch(e){
      showErr("Init error:\n"+String(e));
    }
  });

  yearSel.addEventListener("change", () => {
    recomputeMonthOptions();
    recomputeDayOptions();
    setTilesForSelection();
    onSelectionChange();
  });
  
  monthSel.addEventListener("change", () => {
    recomputeDayOptions();
    setTilesForSelection();
    onSelectionChange();
  });
  
  daySel.addEventListener("change", () => {
    setTilesForSelection();
    onSelectionChange();
  });
  
  document.querySelectorAll('input[name="hours"]').forEach(el => 
    el.addEventListener("change", () => {
      setTilesForSelection();
      onSelectionChange();
    })
  );

  OPACITY.addEventListener("input",()=>setOpacity(parseFloat(OPACITY.value)));
})();
</script>

</body>
</html>
