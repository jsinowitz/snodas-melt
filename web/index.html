<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CN Snowmelt</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: 0; }

    .panel-stack{
      position:absolute;
      right:14px;
      bottom:14px;
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:40;
    }

    .panel-link{
      width:340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .panel-link a{
      color:#0b57d0;
      text-decoration:none;
      font-weight:600;
      font-size:14px;
    }

    .panel-link a:hover{
      text-decoration:underline;
    }

    .panel {
      width: 340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 12px 12px 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
    }
    .panel h3 { margin: 0 0 2px 0; font-size: 16px; line-height: 1.2; }
    .sub { font-size: 13px; color: #333; margin-bottom: 10px; }

    .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .row label { font-size: 14px; }

    .pickrow { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin: 8px 0 10px 0; }
    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.95);
      font-size: 13px;
    }
    select:disabled { opacity: 0.5; }

    .sliderrow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    input[type="range"] { width: 190px; }

    .legend { margin-top: 10px; border-top: 1px solid rgba(0,0,0,0.10); padding-top: 10px; }
    .legend-title { font-size: 13px; font-weight: 600; margin: 0 0 6px 0; }
    .legend-grid { display: grid; grid-template-columns: 20px 1fr; gap: 6px 10px; }
    .swatch { width: 20px; height: 12px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.12); }
    .legend-label { font-size: 12px; color: #222; }

    .err { margin-top: 8px; font-size: 12px; color: #b00020; display: none; white-space: pre-wrap; }

    .cursor-readout {
      position: absolute;
      pointer-events: none;
      z-index: 50;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      padding: 4px 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      transform: translate(10px, 10px);
      display: none;
      white-space: nowrap;
    }
  </style>

  <script src="/config.js"></script>
</head>
<body>
  <div id="map"></div>
  <div id="cursorReadout" class="cursor-readout"></div>

  <div class="panel-stack">
    <div class="panel-link">
      <a href="https://accuweather.atlassian.net/wiki/spaces/AO/pages/3596288537/Snowmelt" id="confluenceLink" target="_blank" rel="noopener">Snowmelt Confluence</a>
    </div>

    <div class="panel" id="mainPanel">
      <h3>CN Snowmelt</h3>
      <div class="sub" id="subtitle">Loadingâ€¦</div>

      <div class="pickrow">
        <select id="yearSel"></select>
        <select id="monthSel"></select>
        <select id="daySel"></select>
      </div>

      <div class="row">
        <input type="radio" name="hours" id="h24" value="24" checked>
        <label for="h24">24 Hour Snowmelt</label>
      </div>
      <div class="row">
        <input type="radio" name="hours" id="h72" value="72">
        <label for="h72">72 Hour Snowmelt</label>
      </div>

      <div class="sliderrow">
        <div style="font-size:13px;">Opacity</div>
        <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.80" />
        <div id="opv" style="font-size:12px;color:#333;width:40px;text-align:right;"></div>
      </div>

      <div class="legend">
        <div class="legend-title" id="legendTitle">Inches of water equivalent</div>
        <div class="legend-grid" id="legendGrid"></div>
      </div>

      <div class="err" id="err"></div>
    </div>
  </div>

<script>
(function () {
  const errBox=document.getElementById("err"),subtitle=document.getElementById("subtitle"),yearSel=document.getElementById("yearSel"),monthSel=document.getElementById("monthSel"),daySel=document.getElementById("daySel"),legendGrid=document.getElementById("legendGrid"),OPACITY=document.getElementById("opacity"),OPV=document.getElementById("opv"),cursorEl=document.getElementById("cursorReadout");
  let ringAbort=null,ringGen=0,ringCenterKey="";
  const DOM="zz",TRACE_INCHES=0.02,MIN_PIXEL_MOVE=2,MIN_REQUEST_GAP_MS=60,QUANT_DEG=0.01,ALPHA_GATE=false,CACHE_TTL_MS=120000,NEIGHBOR_PREFETCH=true;
  const MIN_ZOOM_FOR_READOUT=9;
  let readoutsEnabled=false,lastPoint=null,lastFire=0,rafPending=false,lastKey="",reqId=0;
  const valCache=new Map(),inflight=new Set();
  function showErr(msg){errBox.style.display="block";errBox.textContent=msg}
  function z2(n){return(n<10?"0":"")+n}

  const token=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.MAPBOX_TOKEN)||"";
  if(!token){showErr("Missing MAPBOX_TOKEN. Check /config.js and server environment.");return}
  mapboxgl.accessToken=token;

  const map=new mapboxgl.Map({container:"map",style:"mapbox://styles/mapbox/satellite-streets-v12",center:[-112.5,44.5],zoom:5});
  if(typeof map.isPitching!=="function")map.isPitching=()=>false;
  if(typeof map.isRotating!=="function")map.isRotating=()=>false;

  const VALUE_BASE=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.VALUE_BASE)||window.location.origin;
  const CURSOR_ZMIN = 9;
  const PREFETCH_ZMIN = 9;

  const HF_DATASET_REPO=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.HF_DATASET_REPO)||"Jsinowitz/snodas-snowmelt-cache";
  const HF_TILE_BASE=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.HF_TILE_BASE)||("https://huggingface.co/datasets/"+HF_DATASET_REPO+"/resolve/main");
  const USE_HF_TILES = false;
  const CN_SRC="cn_tracks_src",CN_LINE_GLOW="cn_tracks_src_line_glow",CN_LINE="cn_tracks_src_line";
  const LAYER_ID="melt_layer",SRC_ID="melt_src";

  function muteRoads(map){
    const style=map.getStyle(); if(!style||!style.layers)return;
    const roadLike=l=>{const id=(l.id||"").toLowerCase(),sl=(l["source-layer"]||"").toLowerCase();return id.includes("road")||id.includes("street")||id.includes("highway")||id.includes("bridge")||id.includes("tunnel")||id.includes("motorway")||sl.includes("road")||sl.includes("street")||sl.includes("transportation")};
    for(const l of style.layers){
      if(!roadLike(l))continue;
      if(l.type==="line"){
        if(map.getPaintProperty(l.id,"line-color")!=null)map.setPaintProperty(l.id,"line-color","#c7c7c7");
        if(map.getPaintProperty(l.id,"line-opacity")!=null)map.setPaintProperty(l.id,"line-opacity",0.40);
        if(map.getPaintProperty(l.id,"line-width")!=null){const w=map.getPaintProperty(l.id,"line-width");if(typeof w==="number")map.setPaintProperty(l.id,"line-width",Math.max(0.5,w*0.8))}
      }
      if(l.type==="fill"){
        if(map.getPaintProperty(l.id,"fill-color")!=null)map.setPaintProperty(l.id,"fill-color","#d0d0d0");
        if(map.getPaintProperty(l.id,"fill-opacity")!=null)map.setPaintProperty(l.id,"fill-opacity",0.20);
      }
    }
  }

  function lon2tile(lon,z){return Math.floor(((lon+180)/360)*(1<<z))}
  function lat2tile(lat,z){const r=lat*Math.PI/180,n=Math.log(Math.tan(Math.PI/4+r/2));return Math.floor((1-n/Math.PI)/2*(1<<z))}
  function clamp(n,a,b){return Math.max(a,Math.min(b,n))}
  function tileRangeForBounds(b,z){
    const w=b.getWest(),s=b.getSouth(),e=b.getEast(),n=b.getNorth(),max=(1<<z)-1;
    let x0=lon2tile(w,z),x1=lon2tile(e,z),y0=lat2tile(n,z),y1=lat2tile(s,z);
    x0=clamp(x0,0,max);x1=clamp(x1,0,max);y0=clamp(y0,0,max);y1=clamp(y1,0,max);
    const xmin=Math.min(x0,x1),xmax=Math.max(x0,x1),ymin=Math.min(y0,y1),ymax=Math.max(y0,y1);
    return{xmin,xmax,ymin,ymax}
  }

  function hfTileUrlTemplate(ymd,hours,dom){
    dom=(dom||"zz").toLowerCase();
    return HF_TILE_BASE+`/tilecache/bydate_${dom}_h${hours}_${ymd}_z{z}_{x}_{y}.png`;
  }

  // Custom tile loading with fallback
  function setupTileSourceWithFallback(ymd, hours) {
    const dom = (DOM || "zz").toLowerCase();
    
    // Create a custom tile source that tries HF first, falls back to FastAPI
    const customSource = {
      type: 'raster',
      tiles: [`/tiles/forecast/by_date/{z}/{x}/{y}.png?date_yyyymmdd=${ymd}&hours=${hours}&dom=${dom}`],
      tileSize: 256,
      maxzoom: 12
    };
    
    return customSource;
  }
  
  function setTilesForSelection() {
    const ymd = selectedDateYMD();
    const hours = getHours();
    if (!ymd) return;
    
    subtitle.textContent = subtitleText(ymd, hours);
    renderLegend(hours);
  
    cursorEl.style.display = "none";
    lastKey = "";
    reqId++;
    valCache.clear();
    inflight.clear();
    if (ringAbort) {
      try { ringAbort.abort(); } catch {}
    }
    cursorPrefetchPush.clear();
    ringCenterKey = "";
    
    const sourceConfig = setupTileSourceWithFallback(ymd, hours);
    
    if (map.getSource(SRC_ID)) {
      map.getSource(SRC_ID).setTiles(sourceConfig.tiles);
      map.triggerRepaint();
      prefetched.clear();
      prefetchViewportTiles();
      return;
    }
    
    map.addSource(SRC_ID, sourceConfig);
    map.addLayer({
      id: LAYER_ID,
      type: 'raster',
      source: SRC_ID,
      paint: { 'raster-opacity': parseFloat(OPACITY.value) }
    });
    
    if (map.getLayer(CN_LINE) && map.getLayer(LAYER_ID)) {
      map.moveLayer(CN_LINE_GLOW, LAYER_ID);
      map.moveLayer(CN_LINE, LAYER_ID);
    }
    
    prefetched.clear();
    prefetchViewportTiles();
  }
  
  // Update tileUrl function to always use FastAPI
  function tileUrl(z, x, y, ymd, hours) {
    return `/tiles/forecast/by_date/${z}/${x}/${y}.png?date_yyyymmdd=${ymd}&hours=${hours}&dom=${DOM}`;
  }
  function makeQueue(limit){
    let active=0;const q=[];
    const run=()=>{while(active<limit&&q.length){const fn=q.shift();active++;Promise.resolve().then(fn).catch(()=>{}).finally(()=>{active--;run()})}};
    const push=fn=>{q.push(fn);run()};
    push.clear=()=>{q.length=0};
    return push
  }

  function startCursorRingPrefetch(ymd,hours,qLon,qLat){
    const center=`${ymd}|${hours}|${qLon.toFixed(6)}|${qLat.toFixed(6)}`; if(center===ringCenterKey)return;
    ringCenterKey=center;
    if(ringAbort){try{ringAbort.abort()}catch{}}
    ringAbort=new AbortController(); ringGen++; const myGen=ringGen;
    cursorPrefetchPush.clear();
    const step=QUANT_DEG,N=5,urls=[];
    for(let i=1;i<=N;i++){
      urls.push(`${VALUE_BASE}/value/forecast/by_date?date_yyyymmdd=${ymd}&hours=${hours}&lon=${qLon+step*i}&lat=${qLat}&dom=${DOM}`);
      urls.push(`${VALUE_BASE}/value/forecast/by_date?date_yyyymmdd=${ymd}&hours=${hours}&lon=${qLon-step*i}&lat=${qLat}&dom=${DOM}`);
      urls.push(`${VALUE_BASE}/value/forecast/by_date?date_yyyymmdd=${ymd}&hours=${hours}&lon=${qLon}&lat=${qLat+step*i}&dom=${DOM}`);
      urls.push(`${VALUE_BASE}/value/forecast/by_date?date_yyyymmdd=${ymd}&hours=${hours}&lon=${qLon}&lat=${qLat-step*i}&dom=${DOM}`);
    }
    for(const u of urls)cursorPrefetchPush(async()=>{if(myGen!==ringGen)return;try{await fetch(u,{cache:"force-cache",signal:ringAbort.signal})}catch{}})
  }

  const prefetchPush=makeQueue(10),cursorPrefetchPush=makeQueue(16);
  const prefetched=new Set();

  function prefetchViewportTiles() {
    if (map.getZoom() < PREFETCH_ZMIN) return;
    const ymd = selectedDateYMD();
    if (!ymd) return;
    const hours = getHours();
    const z0 = Math.max(0, Math.floor(map.getZoom()));
    const maxZ = Math.min(12, z0 + 3);
    const b = map.getBounds();
    for (let z = z0 + 1; z <= maxZ; z++) {
      const r = tileRangeForBounds(b, z);
      for (let x = r.xmin; x <= r.xmax; x++) for (let y = r.ymin; y <= r.ymax; y++) {
        const u = tileUrl(z, x, y, ymd, hours);
        if (prefetched.has(u)) continue;
        prefetched.add(u);
        prefetchPush(() => fetch(u, { cache: "force-cache" }));
      }
    }
  }

  function debounce(fn,ms){let t=0;return()=>{clearTimeout(t);t=setTimeout(fn,ms)}}
  const prefetchDebounced=debounce(prefetchViewportTiles,250);

  map.on("load",()=>muteRoads(map));
  map.on("styledata",()=>muteRoads(map));


  const LEGENDS = {
    "24": {
      colors: [
        "#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00",
        "#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"
      ],
      labels: [
        "0.00 to trace","trace to 0.02","0.02 to 0.04","0.04 to 0.08","0.08 to 0.12","0.12 to 0.16",
        "0.16 to 0.20","0.20 to 0.39","0.39 to 0.59","0.59 to 0.79","0.79 to 0.98","0.98 to 1.4",
        "1.4 to 2.0","2.0 to 3.0","3.0 to 4.0","4.0 to 5.0","> 5.0"
      ]
    },
    "72": {
      colors: [
        "#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00",
        "#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"
      ],
      labels: [
        "0.00 to trace","trace to 0.04","0.04 to 0.08","0.08 to 0.16","0.16 to 0.24","0.24 to 0.31",
        "0.31 to 0.39","0.39 to 0.79","0.79 to 1.4","1.4 to 2.0","2.0 to 3.0","3.0 to 3.9",
        "3.9 to 5.0","5.0 to 6.5","6.5 to 8.0","8.0 to 9.8","> 9.8"
      ]
    }
  };

  function renderLegend(hours){
    const L=LEGENDS[String(hours)]||LEGENDS["24"];
    legendGrid.innerHTML="";
    for(let i=0;i<L.colors.length;i++){
      const sw=document.createElement("div");sw.className="swatch";sw.style.background=L.colors[i];
      const lb=document.createElement("div");lb.className="legend-label";lb.textContent=L.labels[i]||"";
      legendGrid.appendChild(sw);legendGrid.appendChild(lb);
    }
  }

  function getHours(){const el=document.querySelector('input[name="hours"]:checked');return el?parseInt(el.value,10):24}
  function selectedDateYMD(){const y=yearSel.value,m=monthSel.value,d=daySel.value; if(!y||!m||!d)return null; return`${y}${m}${d}`}
  function subtitleText(yyyymmdd,hours){const y=yyyymmdd.slice(0,4),m=yyyymmdd.slice(4,6),d=yyyymmdd.slice(6,8);return`${hours} Hour snowmelt ending on ${y}-${m}-${d} 05Z`}

  async function fetchCnGeojson(){const url="cn_tracks.geojson",r=await fetch(url,{cache:"no-store"});if(!r.ok)throw new Error(`fetch ${url} -> HTTP ${r.status}`);return await r.json()}

  function geojsonBounds(gj){
    let minLon=180,minLat=90,maxLon=-180,maxLat=-90;
    function addCoord(c){if(!c||c.length<2)return;const lon=+c[0],lat=+c[1];if(!isFinite(lon)||!isFinite(lat))return;if(lon<minLon)minLon=lon;if(lat<minLat)minLat=lat;if(lon>maxLon)maxLon=lon;if(lat>maxLat)maxLat=lat}
    function walk(coords){if(!coords)return;if(typeof coords[0]==="number"){addCoord(coords);return}for(const x of coords)walk(x)}
    const feats=(gj&&gj.features)||[];
    for(const f of feats){const g=f&&f.geometry;if(g&&g.coordinates)walk(g.coordinates)}
    if(minLon>maxLon||minLat>maxLat)return null;
    return[[minLon,minLat],[maxLon,maxLat]]
  }

  let cnBbox=null;

  async function addCnTracksFromGeojson(gj){
    if(map.getSource(CN_SRC)){map.getSource(CN_SRC).setData(gj);return}
    map.addSource(CN_SRC,{type:"geojson",data:gj});
    map.addLayer({id:CN_LINE_GLOW,type:"line",source:CN_SRC,filter:["any",["==",["geometry-type"],"LineString"],["==",["geometry-type"],"MultiLineString"]],layout:{"line-join":"round","line-cap":"round"},paint:{"line-color":"#ff0000","line-opacity":0.85,"line-blur":2.0,"line-width":["interpolate",["linear"],["zoom"],4,2.0,6,4.0,8,6.0,10,8.0,12,10.0,14,12.0]}});
    map.addLayer({id:CN_LINE,type:"line",source:CN_SRC,filter:["any",["==",["geometry-type"],"LineString"],["==",["geometry-type"],"MultiLineString"]],layout:{"line-join":"round","line-cap":"round"},paint:{"line-color":"#ffffff","line-opacity":0.95,"line-width":["interpolate",["linear"],["zoom"],4,0.8,6,1.6,8,2.4,10,3.2,12,4.0,14,4.8]}});
  }

  function setOpacity(v){OPV.textContent=v.toFixed(2);if(map.getLayer(LAYER_ID))map.setPaintProperty(LAYER_ID,"raster-opacity",v)}

  // function setTilesForSelection(){
  //   const ymd=selectedDateYMD(),hours=getHours(); if(!ymd)return;
  //   subtitle.textContent=subtitleText(ymd,hours);
  //   renderLegend(hours);

  //   const tiles = USE_HF_TILES
  //     ? [hfTileUrlTemplate(ymd,hours,DOM)]
  //     : [`/tiles/forecast/by_date/{z}/{x}/{y}.png?date_yyyymmdd=${ymd}&hours=${hours}&dom=${DOM}`];

  //   cursorEl.style.display="none";lastKey="";reqId++;valCache.clear();inflight.clear();
  //   if(ringAbort){try{ringAbort.abort()}catch{}}
  //   cursorPrefetchPush.clear();ringCenterKey="";
  //   if(map.getSource(SRC_ID)){map.getSource(SRC_ID).setTiles(tiles);map.triggerRepaint();prefetched.clear();prefetchViewportTiles();return}
  //   map.addSource(SRC_ID,{type:"raster",tiles,tileSize:256,maxzoom:10});
  //   map.addLayer({id:LAYER_ID,type:"raster",source:SRC_ID,paint:{"raster-opacity":parseFloat(OPACITY.value)}});
  //   if(map.getLayer(CN_LINE)&&map.getLayer(LAYER_ID)){map.moveLayer(CN_LINE_GLOW,LAYER_ID);map.moveLayer(CN_LINE,LAYER_ID)}
  //   prefetched.clear();prefetchViewportTiles();
  // }

  function setSelectOptions(sel,options,value,disabledSet){
    sel.innerHTML="";
    for(const opt of options){
      const o=document.createElement("option");
      o.value=opt.value;o.textContent=opt.label;
      if(disabledSet&&disabledSet.has(opt.value))o.disabled=true;
      sel.appendChild(o);
    }
    if(value)sel.value=value;
  }

  function monthName(m){const names=["January","February","March","April","May","June","July","August","September","October","November","December"];return names[parseInt(m,10)-1]||m}

  let available=[],availableSet=new Set();

  function recomputeDayOptions(){
    const y=yearSel.value,m=monthSel.value; if(!y||!m)return;
    const days=[],disabled=new Set(),monthDays=31;
    for(let dd=1;dd<=monthDays;dd++){
      const d2=z2(dd),ymd=`${y}${m}${d2}`;
      days.push({value:d2,label:String(dd)});
      if(!availableSet.has(ymd))disabled.add(d2);
    }
    const prev=daySel.value;
    setSelectOptions(daySel,days,prev,disabled);
    if(daySel.options[daySel.selectedIndex]&&daySel.options[daySel.selectedIndex].disabled){
      const firstEnabled=Array.from(daySel.options).find(o=>!o.disabled);
      if(firstEnabled)daySel.value=firstEnabled.value;
    }
  }

  function recomputeMonthOptions(){
    const y=yearSel.value,months=[],disabled=new Set();
    for(let mm=1;mm<=12;mm++){
      const m2=z2(mm);
      months.push({value:m2,label:monthName(m2)});
      const hasAny=available.some(d=>d.startsWith(`${y}${m2}`));
      if(!hasAny)disabled.add(m2);
    }
    const prev=monthSel.value;
    setSelectOptions(monthSel,months,prev,disabled);
    if(monthSel.options[monthSel.selectedIndex]&&monthSel.options[monthSel.selectedIndex].disabled){
      const firstEnabled=Array.from(monthSel.options).find(o=>!o.disabled);
      if(firstEnabled)monthSel.value=firstEnabled.value;
    }
  }

  function initSelectorsFromAvailable(){
    availableSet=new Set(available);
    const years=Array.from(new Set(available.map(d=>d.slice(0,4)))).sort();
    setSelectOptions(yearSel,years.map(y=>({value:y,label:y})),years[years.length-1]);
    recomputeMonthOptions();recomputeDayOptions();
    const latest=available[available.length-1];
    if(latest){yearSel.value=latest.slice(0,4);recomputeMonthOptions();monthSel.value=latest.slice(4,6);recomputeDayOptions();daySel.value=latest.slice(6,8)}
  }

  async function loadAvailable(){
    const r=await fetch(`${VALUE_BASE}/forecast/available_days?lookback_days=5`,{cache:"no-store"});
    if(!r.ok)throw new Error(`forecast/available_days -> HTTP ${r.status}`);
    const j=await r.json();
    available=(j&&j.available_dates?j.available_dates:[]).slice();
    return j;
  }

  map.on("error",(e)=>showErr("Map error:\n"+(e&&e.error?e.error.message:String(e))));

  function showCursorReadout(px,py,text){
    cursorEl.style.left=px+"px";cursorEl.style.top=py+"px";
    if(!text){cursorEl.style.display="none";return}
    cursorEl.textContent=text;cursorEl.style.display="block";
  }

  function quantize(v,q){return Math.round(v/q)*q}

  function pixelLooksEmpty(point){
    if(!ALPHA_GATE)return false;
    if(!map.getLayer(LAYER_ID))return false;
    const f=map.queryRenderedFeatures(point,{layers:[LAYER_ID]});
    return(!f||!f.length);
  }

  function cacheGet(key){
    const v=valCache.get(key);
    if(!v)return null;
    if(Date.now()-v.t>CACHE_TTL_MS){valCache.delete(key);return null}
    return v.txt;
  }
  function cacheSet(key,txt){valCache.set(key,{t:Date.now(),txt})}

  function neighborKeys(ymd,hours,qLon,qLat){
    const step=QUANT_DEG,N=5,f=(lon,lat)=>`${ymd}|${hours}|${lon.toFixed(6)}|${lat.toFixed(6)}`,out=[];
    for(let dx=-N;dx<=N;dx++)for(let dy=-N;dy<=N;dy++){
      if(dx===0&&dy===0)continue;
      if(Math.abs(dx)+Math.abs(dy)>N)continue;
      out.push(f(qLon+dx*step,qLat+dy*step));
    }
    return out;
  }

  function urlFor(ymd,hours,lon,lat){
  return `${VALUE_BASE}/value/forecast/by_date` +
    `?date_yyyymmdd=${encodeURIComponent(ymd)}` +
    `&hours=${encodeURIComponent(hours)}` +
    `&lon=${encodeURIComponent(lon)}` +
    `&lat=${encodeURIComponent(lat)}` +
    `&dom=${encodeURIComponent(DOM)}`;
}

async function fetchAndCache(ymd, hours, qLon, qLat, key, updateUi, point){
  if(inflight.has(key)) return;
  inflight.add(key);

  const myReq = ++reqId;
  const url = urlFor(ymd, hours, qLon, qLat);

  const finish = (txt) => {
    cacheSet(key, txt);
    if(updateUi && point) showCursorReadout(point.x, point.y, txt);
    inflight.delete(key);
  };

  try{
    const r = await fetch(url, { cache: "no-store" });

    if(myReq !== reqId){ inflight.delete(key); return; }

    if(!r.ok){
      finish("");
      return;
    }

    let j = null;
    const ct = (r.headers.get("content-type") || "").toLowerCase();

    try{
      if(ct.includes("application/json")){
        j = await r.json();
      } else {
        const txt = (await r.text()).trim();
        const n = Number(txt);
        j = Number.isFinite(n) ? { inches: n } : null;
      }
    } catch {
      j = null;
    }

    if(myReq !== reqId){ inflight.delete(key); return; }

    const inches =
      (j && typeof j.inches_1dp === "number") ? j.inches_1dp :
      (j && typeof j.inches === "number") ? j.inches :
      null;

    const txt = (inches != null && inches > TRACE_INCHES) ? (Number(inches).toFixed(1) + " in") : "";
    finish(txt);

    if(NEIGHBOR_PREFETCH){
      const nks = neighborKeys(ymd, hours, qLon, qLat);
      for(const nk of nks){
        if(valCache.has(nk) || inflight.has(nk)) continue;
        const parts = nk.split("|"), lon = parseFloat(parts[2]), lat = parseFloat(parts[3]);
        fetchAndCache(ymd, hours, lon, lat, nk, false, null);
      }
    }
  } catch {
    if(myReq !== reqId){ inflight.delete(key); return; }
    finish("");
  }
}


  function shouldReadout(){
    const z=map.getZoom();
    const ok=z>=MIN_ZOOM_FOR_READOUT;
    if(!ok&&readoutsEnabled){
      readoutsEnabled=false;
      lastKey="";
      showCursorReadout(0,0,"");
      if(ringAbort){try{ringAbort.abort()}catch{}}
      cursorPrefetchPush.clear();
      ringCenterKey="";
    } else if(ok&&!readoutsEnabled) readoutsEnabled=true;
    return ok;
  }

async function fetchValueAt(lngLat, point) {
  if (map.getZoom() < CURSOR_ZMIN) {
    showCursorReadout(point.x, point.y, "");
    lastKey = "";
    return;
  }

  const ymd = selectedDateYMD();
  if (!ymd) {
    showCursorReadout(point.x, point.y, "");
    lastKey = "";
    return;
  }

  if (pixelLooksEmpty(point)) {
    showCursorReadout(point.x, point.y, "");
    lastKey = "";
    return;
  }

  const hours = getHours();
  const qLon = quantize(lngLat.lng, QUANT_DEG);
  const qLat = quantize(lngLat.lat, QUANT_DEG);

  startCursorRingPrefetch(ymd, hours, qLon, qLat);

  const key = `${ymd}|${hours}|${qLon.toFixed(6)}|${qLat.toFixed(6)}`;
  if (key === lastKey) return;
  lastKey = key;

  const cached = cacheGet(key);
  if (cached != null) {
    showCursorReadout(point.x, point.y, cached);
    return;
  }

  showCursorReadout(point.x, point.y, "Loading...");

  // Fire-and-forget is fine, because fetchAndCache now ALWAYS resolves the UI.
  fetchAndCache(ymd, hours, qLon, qLat, key, true, point);
}


  function maybeFire(){
    rafPending=false;
    if(!lastPoint)return;
    if(!shouldReadout())return;
    const now=Date.now();
    if(now-lastFire<MIN_REQUEST_GAP_MS)return;
    const{lngLat,point}=lastPoint;
    if(lastPoint.prevPoint){
      const dx=point.x-lastPoint.prevPoint.x,dy=point.y-lastPoint.prevPoint.y;
      if((dx*dx+dy*dy)<(MIN_PIXEL_MOVE*MIN_PIXEL_MOVE))return;
    }
    lastFire=now;
    fetchValueAt(lngLat,point);
    lastPoint.prevPoint=point;
  }

  map.on("mousemove",(e)=>{
    if(cursorEl.style.display!=="none"){cursorEl.style.left=e.point.x+"px";cursorEl.style.top=e.point.y+"px"}
    if(!shouldReadout()){lastPoint=null;return}
    lastPoint={lngLat:e.lngLat,point:e.point,prevPoint:lastPoint?lastPoint.prevPoint:null};
    if(!rafPending){rafPending=true;requestAnimationFrame(maybeFire)}
  });

  map.on("mouseout",()=>{
    lastKey="";
    showCursorReadout(0,0,"");
    if(ringAbort){try{ringAbort.abort()}catch{}}
    cursorPrefetchPush.clear();
    ringCenterKey="";
  });

  map.on("zoomend",()=>{shouldReadout();prefetchDebounced()});
  map.on("moveend",prefetchDebounced);
  map.on("zoomend", () => {
    if (map.getZoom() < CURSOR_ZMIN) {
      lastKey = "";
      showCursorReadout(0,0,"");
      if (ringAbort) { try { ringAbort.abort(); } catch {} }
      cursorPrefetchPush.clear();
      ringCenterKey = "";
    }
    prefetchDebounced();
  });

  map.on("load",async()=>{
    try{
      const gj=await fetchCnGeojson();
      await addCnTracksFromGeojson(gj);
      const b=geojsonBounds(gj);
      if(b){cnBbox=b;map.fitBounds(b,{padding:40,duration:0,maxZoom:7})}
      renderLegend(24);
      await loadAvailable();
      if(!available.length){showErr("No available days returned from /forecast/available_days");return}
      initSelectorsFromAvailable();
      setTilesForSelection();
      prefetchViewportTiles();
      setOpacity(parseFloat(OPACITY.value));
      shouldReadout();
    }catch(e){showErr("Init error:\n"+String(e))}
  });

  yearSel.addEventListener("change",()=>{recomputeMonthOptions();recomputeDayOptions();setTilesForSelection()});
  monthSel.addEventListener("change",()=>{recomputeDayOptions();setTilesForSelection()});
  daySel.addEventListener("change",()=>setTilesForSelection());
  document.querySelectorAll('input[name="hours"]').forEach(el=>el.addEventListener("change",()=>setTilesForSelection()));
  OPACITY.addEventListener("input",()=>setOpacity(parseFloat(OPACITY.value)));
})();
</script>
</body>
</html>
