<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CN Snowmelt</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: 0; }

    .panel-stack{
      position:absolute;
      right:14px;
      bottom:14px;
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:40;
    }

    .panel-link{
      width:340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .panel-link a{
      color:#0b57d0;
      text-decoration:none;
      font-weight:600;
      font-size:14px;
    }

    .panel-link a:hover{
      text-decoration:underline;
    }

    .panel {
      width: 340px;
      background: rgba(255,255,255,0.90);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      padding: 12px 12px 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
    }
    .panel h3 { margin: 0 0 2px 0; font-size: 16px; line-height: 1.2; }
    .sub { font-size: 13px; color: #333; margin-bottom: 10px; }

    .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .row label { font-size: 14px; }

    .pickrow { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin: 8px 0 10px 0; }
    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.95);
      font-size: 13px;
    }
    select:disabled { opacity: 0.5; }

    .sliderrow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    input[type="range"] { width: 190px; }

    .legend { margin-top: 10px; border-top: 1px solid rgba(0,0,0,0.10); padding-top: 10px; }
    .legend-title { font-size: 13px; font-weight: 600; margin: 0 0 6px 0; }
    .legend-grid { display: grid; grid-template-columns: 20px 1fr; gap: 6px 10px; }
    .swatch { width: 20px; height: 12px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.12); }
    .legend-label { font-size: 12px; color: #222; }

    .err { margin-top: 8px; font-size: 12px; color: #b00020; display: none; white-space: pre-wrap; }

    .cursor-readout {
      position: absolute;
      pointer-events: none;
      z-index: 50;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      padding: 4px 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #111;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      transform: translate(10px, 10px);
      display: none;
      white-space: nowrap;
    }
  </style>

<script>
(function () {
  const errBox=document.getElementById("err"),subtitle=document.getElementById("subtitle"),yearSel=document.getElementById("yearSel"),monthSel=document.getElementById("monthSel"),daySel=document.getElementById("daySel"),legendGrid=document.getElementById("legendGrid"),OPACITY=document.getElementById("opacity"),OPV=document.getElementById("opv"),cursorEl=document.getElementById("cursorReadout");

  const DOM="zz";
  const TRACE_INCHES=0.02;
  const ALPHA_GATE=false;

  const MIN_ZOOM_FOR_READOUT=9;
  const CURSOR_ZMIN=9;
  const PREFETCH_ZMIN=9;

  const INITIAL_BOUNDS=[[-130.359201,29.915607],[-63.228204,60.840431]];

  let readoutsEnabled=false,lastKey="";

  function showErr(msg){errBox.style.display="block";errBox.textContent=msg}
  function z2(n){return(n<10?"0":"")+n}

  const token=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.MAPBOX_TOKEN)||"";
  if(!token){showErr("Missing MAPBOX_TOKEN. Check /config.js and server environment.");return}
  mapboxgl.accessToken=token;

  const map=new mapboxgl.Map({
    container:"map",
    style:"mapbox://styles/mapbox/satellite-streets-v12",
    bounds: INITIAL_BOUNDS,
    fitBoundsOptions:{padding:40,duration:0,maxZoom:7}
  });

  if(typeof map.isPitching!=="function")map.isPitching=()=>false;
  if(typeof map.isRotating!=="function")map.isRotating=()=>false;

  const VALUE_BASE=(window.__SNODAS_CONFIG__&&window.__SNODAS_CONFIG__.VALUE_BASE)||window.location.origin;

  const CN_LINE_GLOW="cn_tracks_src_line_glow",CN_LINE="cn_tracks_src_line";
  const LAYER_ID="melt_layer",SRC_ID="melt_src";

  function tracksReady(){return !!(map.getLayer(CN_LINE)||map.getLayer(CN_LINE_GLOW))}

  const TRACK_CORRIDOR_MILES = 8;
  const TRACK_CORRIDOR_PX_CAP = 90;
  
  function milesToPixels(miles, latDeg, zoom){
    const meters = miles * 1609.344;
    const lat = latDeg * Math.PI / 180;
    const metersPerPixel = 156543.03392 * Math.cos(lat) / Math.pow(2, zoom);
    if (!isFinite(metersPerPixel) || metersPerPixel <= 0) return TRACK_CORRIDOR_PX_CAP;
    return meters / metersPerPixel;
  }
  
  function nearTrack(point, lngLat){
    const layers = [];
    if (map.getLayer(CN_LINE)) layers.push(CN_LINE);
    if (map.getLayer(CN_LINE_GLOW)) layers.push(CN_LINE_GLOW);
    if (!layers.length) return false;
  
    const z = map.getZoom();
    const rRaw = milesToPixels(TRACK_CORRIDOR_MILES, lngLat.lat, z);
    const r = Math.max(6, Math.min(TRACK_CORRIDOR_PX_CAP, Math.round(rRaw)));
  
    const bbox = [
      [point.x - r, point.y - r],
      [point.x + r, point.y + r]
    ];
  
    const feats = map.queryRenderedFeatures(bbox, { layers });
    return !!(feats && feats.length);
  }

  function muteRoads(map){
    const style=map.getStyle(); if(!style||!style.layers)return;
    const roadLike=l=>{const id=(l.id||"").toLowerCase(),sl=(l["source-layer"]||"").toLowerCase();return id.includes("road")||id.includes("street")||id.includes("highway")||id.includes("bridge")||id.includes("tunnel")||id.includes("motorway")||sl.includes("road")||sl.includes("street")||sl.includes("transportation")};
    for(const l of style.layers){
      if(!roadLike(l))continue;
      if(l.type==="line"){
        if(map.getPaintProperty(l.id,"line-color")!=null)map.setPaintProperty(l.id,"line-color","#c7c7c7");
        if(map.getPaintProperty(l.id,"line-opacity")!=null)map.setPaintProperty(l.id,"line-opacity",0.40);
        if(map.getPaintProperty(l.id,"line-width")!=null){const w=map.getPaintProperty(l.id,"line-width");if(typeof w==="number")map.setPaintProperty(l.id,"line-width",Math.max(0.5,w*0.8))}
      }
      if(l.type==="fill"){
        if(map.getPaintProperty(l.id,"fill-color")!=null)map.setPaintProperty(l.id,"fill-color","#d0d0d0");
        if(map.getPaintProperty(l.id,"fill-opacity")!=null)map.setPaintProperty(l.id,"fill-opacity",0.20);
      }
    }
  }

  function lon2tile(lon,z){return Math.floor(((lon+180)/360)*(1<<z))}
  function lat2tile(lat,z){const r=lat*Math.PI/180,n=Math.log(Math.tan(Math.PI/4+r/2));return Math.floor((1-n/Math.PI)/2*(1<<z))}
  function clamp(n,a,b){return Math.max(a,Math.min(b,n))}
  function tileRangeForBounds(b,z){
    const w=b.getWest(),s=b.getSouth(),e=b.getEast(),n=b.getNorth(),max=(1<<z)-1;
    let x0=lon2tile(w,z),x1=lon2tile(e,z),y0=lat2tile(n,z),y1=lat2tile(s,z);
    x0=clamp(x0,0,max);x1=clamp(x1,0,max);y0=clamp(y0,0,max);y1=clamp(y1,0,max);
    const xmin=Math.min(x0,x1),xmax=Math.max(x0,x1),ymin=Math.min(y0,y1),ymax=Math.max(y0,y1);
    return{xmin,xmax,ymin,ymax}
  }

  function makeQueue(limit){
    let active=0;const q=[];
    const run=()=>{while(active<limit&&q.length){const fn=q.shift();active++;Promise.resolve().then(fn).catch(()=>{}).finally(()=>{active--;run()})}};
    const push=fn=>{q.push(fn);run()};
    push.clear=()=>{q.length=0};
    return push
  }

  function tileUrl(z,x,y,ymd,hours){
    return `/tiles/forecast/by_date/${z}/${x}/${y}.png?date_yyyymmdd=${ymd}&hours=${hours}&dom=${DOM}`;
  }

  const prefetchPush=makeQueue(10);
  const prefetched=new Set();

  function prefetchViewportTiles(){
    if(map.getZoom()<PREFETCH_ZMIN)return;
    const ymd=selectedDateYMD();
    if(!ymd)return;
    const hours=getHours();
    const z0=Math.max(0,Math.floor(map.getZoom()));
    const maxZ=Math.min(12,z0+3);
    const b=map.getBounds();
    for(let z=z0+1;z<=maxZ;z++){
      const r=tileRangeForBounds(b,z);
      for(let x=r.xmin;x<=r.xmax;x++)for(let y=r.ymin;y<=r.ymax;y++){
        const u=tileUrl(z,x,y,ymd,hours);
        if(prefetched.has(u))continue;
        prefetched.add(u);
        prefetchPush(()=>fetch(u,{cache:"force-cache"}));
      }
    }
  }

  function debounce(fn,ms){let t=0;return()=>{clearTimeout(t);t=setTimeout(fn,ms)}}
  const prefetchDebounced=debounce(prefetchViewportTiles,250);

  map.on("load",()=>muteRoads(map));
  map.on("styledata",()=>muteRoads(map));

  const LEGENDS={
    "24":{
      colors:["#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00","#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"],
      labels:["0.00 to trace","trace to 0.02","0.02 to 0.04","0.04 to 0.08","0.08 to 0.12","0.12 to 0.16","0.16 to 0.20","0.20 to 0.39","0.39 to 0.59","0.59 to 0.79","0.79 to 0.98","0.98 to 1.4","1.4 to 2.0","2.0 to 3.0","3.0 to 4.0","4.0 to 5.0","> 5.0"]
    },
    "72":{
      colors:["#dcdcdc","#990000","#cc3333","#ff6666","#cccc66","#ff8c00","#ffff66","#99ff99","#00ff00","#66cc66","#6666ff","#3333cc","#000099","#990099","#4b0082","#2f004f","#000000"],
      labels:["0.00 to trace","trace to 0.04","0.04 to 0.08","0.08 to 0.16","0.16 to 0.24","0.24 to 0.31","0.31 to 0.39","0.39 to 0.79","0.79 to 1.4","1.4 to 2.0","2.0 to 3.0","3.0 to 3.9","3.9 to 5.0","5.0 to 6.5","6.5 to 8.0","8.0 to 9.8","> 9.8"]
    }
  };

  function renderLegend(hours){
    const L=LEGENDS[String(hours)]||LEGENDS["24"];
    legendGrid.innerHTML="";
    for(let i=0;i<L.colors.length;i++){
      const sw=document.createElement("div");sw.className="swatch";sw.style.background=L.colors[i];
      const lb=document.createElement("div");lb.className="legend-label";lb.textContent=L.labels[i]||"";
      legendGrid.appendChild(sw);legendGrid.appendChild(lb);
    }
  }

  function getHours(){const el=document.querySelector('input[name="hours"]:checked');return el?parseInt(el.value,10):24}
  function selectedDateYMD(){const y=yearSel.value,m=monthSel.value,d=daySel.value; if(!y||!m||!d)return null; return`${y}${m}${d}`}
  function subtitleText(yyyymmdd,hours){const y=yyyymmdd.slice(0,4),m=yyyymmdd.slice(4,6),d=yyyymmdd.slice(6,8);return`${hours} Hour snowmelt ending on ${y}-${m}-${d} 05Z`}

  async function addCnTracksVectorTiles(){
    const SRC = "cn_tracks_vt";
    const CN_MAX_ZOOM = 7;

    if (map.getSource(SRC)) return;

    map.addSource(SRC, {
      type: "vector",
      tiles: [`${VALUE_BASE}/cn_tiles/{z}/{x}/{y}.pbf`],
      minzoom: 0,
      maxzoom: CN_MAX_ZOOM,
      bounds: [-170, 29, -63, 90]
    });

    map.addLayer({
      id: CN_LINE_GLOW,
      type: "line",
      source: SRC,
      "source-layer": "cn_tracks",
      minzoom: 0,
      maxzoom: 24,
      layout: { "line-join": "round", "line-cap": "round" },
      paint: {
        "line-color": "#ff0000",
        "line-opacity": 0.85,
        "line-blur": 2.0,
        "line-width": ["interpolate", ["linear"], ["zoom"], 4, 2.0, 6, 4.0, 8, 6.0, 10, 8.0, 12, 10.0, 14, 12.0]
      }
    });

    map.addLayer({
      id: CN_LINE,
      type: "line",
      source: SRC,
      "source-layer": "cn_tracks",
      minzoom: 0,
      maxzoom: 24,
      layout: { "line-join": "round", "line-cap": "round" },
      paint: {
        "line-color": "#ffffff",
        "line-opacity": 0.95,
        "line-width": ["interpolate", ["linear"], ["zoom"], 4, 0.8, 6, 1.6, 8, 2.4, 10, 3.2, 12, 4.0, 14, 4.8]
      }
    });
  }

  function setOpacity(v){OPV.textContent=v.toFixed(2);if(map.getLayer(LAYER_ID))map.setPaintProperty(LAYER_ID,"raster-opacity",v)}

  let selGen=0;

  function setTilesForSelection(){
    const ymd = selectedDateYMD();
    const hours = getHours();
    if(!ymd) return;
    
    selGen++;
    subtitle.textContent = subtitleText(ymd, hours);
    renderLegend(hours);
    
    cursorEl.style.display = "none";
    lastKey = "";
    
    const tiles = [`/tiles/forecast/by_date/{z}/{x}/{y}.png?date_yyyymmdd=${ymd}&hours=${hours}&dom=${DOM}`];
    
    // Remove and re-add to force tile refresh
    if (map.getLayer(LAYER_ID)) {
      map.removeLayer(LAYER_ID);
    }
    if (map.getSource(SRC_ID)) {
      map.removeSource(SRC_ID);
    }
    
    // Small delay to ensure removal completes
    setTimeout(() => {
      map.addSource(SRC_ID, {
        type: "raster",
        tiles: tiles,
        tileSize: 256,
        maxzoom: 12,
        bounds: [-170, 29, -40, 90]
      });
      
      map.addLayer({
        id: LAYER_ID,
        type: "raster",
        source: SRC_ID,
        paint: {
          "raster-opacity": parseFloat(OPACITY.value)
        }
      });
      
      if (map.getLayer(CN_LINE_GLOW)) {
        map.moveLayer(LAYER_ID, CN_LINE_GLOW);
      }
    }, 50);
    
    prefetched.clear();
    prefetchViewportTiles();
  }

  function setSelectOptions(sel,options,value,disabledSet){
    sel.innerHTML="";
    for(const opt of options){
      const o=document.createElement("option");
      o.value=opt.value;o.textContent=opt.label;
      if(disabledSet&&disabledSet.has(opt.value))o.disabled=true;
      sel.appendChild(o);
    }
    if(value)sel.value=value;
  }

  function monthName(m){const names=["January","February","March","April","May","June","July","August","September","October","November","December"];return names[parseInt(m,10)-1]||m}

  let available=[],availableSet=new Set();

  function recomputeDayOptions(){
    const y=yearSel.value,m=monthSel.value; if(!y||!m)return;
    const days=[],disabled=new Set(),monthDays=31;
    for(let dd=1;dd<=monthDays;dd++){
      const d2=z2(dd),ymd=`${y}${m}${d2}`;
      days.push({value:d2,label:String(dd)});
      if(!availableSet.has(ymd))disabled.add(d2);
    }
    const prev=daySel.value;
    setSelectOptions(daySel,days,prev,disabled);
    if(daySel.options[daySel.selectedIndex]&&daySel.options[daySel.selectedIndex].disabled){
      const firstEnabled=Array.from(daySel.options).find(o=>!o.disabled);
      if(firstEnabled)daySel.value=firstEnabled.value;
    }
  }

  function recomputeMonthOptions(){
    const y=yearSel.value,months=[],disabled=new Set();
    for(let mm=1;mm<=12;mm++){
      const m2=z2(mm);
      months.push({value:m2,label:monthName(m2)});
      const hasAny=available.some(d=>d.startsWith(`${y}${m2}`));
      if(!hasAny)disabled.add(m2);
    }
    const prev=monthSel.value;
    setSelectOptions(monthSel,months,prev,disabled);
    if(monthSel.options[monthSel.selectedIndex]&&monthSel.options[monthSel.selectedIndex].disabled){
      const firstEnabled=Array.from(monthSel.options).find(o=>!o.disabled);
      if(firstEnabled)monthSel.value=firstEnabled.value;
    }
  }

  function initSelectorsFromAvailable(){
    availableSet=new Set(available);
    const years=Array.from(new Set(available.map(d=>d.slice(0,4)))).sort();
    setSelectOptions(yearSel,years.map(y=>({value:y,label:y})),years[years.length-1]);
    recomputeMonthOptions();recomputeDayOptions();
    const latest=available[available.length-1];
    if(latest){
      yearSel.value=latest.slice(0,4);
      recomputeMonthOptions();
      monthSel.value=latest.slice(4,6);
      recomputeDayOptions();
      daySel.value=latest.slice(6,8);
    }
  }

  async function loadAvailable(){
    const r=await fetch(`${VALUE_BASE}/forecast/available_days?lookback_days=5`,{cache:"no-store"});
    if(!r.ok)throw new Error(`forecast/available_days -> HTTP ${r.status}`);
    const j=await r.json();
    available=(j&&j.available_dates?j.available_dates:[]).slice();
    return j;
  }

  function showCursorReadout(px,py,text){
    cursorEl.style.left=px+"px";
    cursorEl.style.top=py+"px";
    if(!text){cursorEl.style.display="none";return}
    cursorEl.textContent=text;
    cursorEl.style.display="block";
  }

  // ========== VIEWPORT GRID PREFETCH SYSTEM ==========
  let viewportGrid = null;
  let gridFetchInProgress = false;
  let lastGridBounds = null;
  let lastGridKey = "";
  let pendingCursorUpdate = null;

  function shouldRefetchGrid() {
    if (!viewportGrid) return true;
    
    const ymd = selectedDateYMD();
    const hours = getHours();
    const dateKey = `${ymd}|${hours}`;
    
    if (lastGridKey !== dateKey) return true;
    
    if (!lastGridBounds) return true;
    
    const currentBounds = map.getBounds();
    const cw = currentBounds.getWest();
    const cs = currentBounds.getSouth();
    const ce = currentBounds.getEast();
    const cn = currentBounds.getNorth();
    
    const gw = lastGridBounds[0];
    const gs = lastGridBounds[1];
    const ge = lastGridBounds[2];
    const gn = lastGridBounds[3];
    
    const lonBuffer = (ge - gw) * 0.2;
    const latBuffer = (gn - gs) * 0.2;
    
    if (cw < gw + lonBuffer || ce > ge - lonBuffer || 
        cs < gs + latBuffer || cn > gn - latBuffer) {
      return true;
    }
    
    return false;
  }

  async function fetchViewportGrid() {
    if (gridFetchInProgress) return;
    
    const ymd = selectedDateYMD();
    if (!ymd) return;
    
    const hours = getHours();
    
    gridFetchInProgress = true;
    
    try {
      const viewBounds = map.getBounds();
      const center = viewBounds.getCenter();
      const lonSpan = viewBounds.getEast() - viewBounds.getWest();
      const latSpan = viewBounds.getNorth() - viewBounds.getSouth();
      
      const expandedBounds = [
        center.lng - (lonSpan * 0.75),
        center.lat - (latSpan * 0.75),
        center.lng + (lonSpan * 0.75),
        center.lat + (latSpan * 0.75)
      ];
      
      const payload = {
        date_yyyymmdd: ymd,
        hours: hours,
        dom: DOM,
        bounds: expandedBounds,
        resolution: 25
      };
      
      const r = await fetch(`${VALUE_BASE}/value/forecast/viewport_grid`, {
        method: "POST",
        headers: {"content-type": "application/json"},
        body: JSON.stringify(payload),
        cache: "no-store"
      });
      
      if (!r.ok) {
        console.error(`[grid] fetch failed: ${r.status} ${r.statusText}`);
        gridFetchInProgress = false;
        return;
      }
      
      const data = await r.json();
      
      viewportGrid = data;
      lastGridBounds = data.bounds;
      lastGridKey = `${ymd}|${hours}`;
      
      console.log(`[grid] loaded ${data.resolution}x${data.resolution} grid for viewport`);
      
      if (pendingCursorUpdate) {
        const {lngLat, point} = pendingCursorUpdate;
        updateCursorReadout(lngLat, point);
      }
      
    } catch (e) {
      console.error("[grid] fetch error:", e);
    } finally {
      gridFetchInProgress = false;
    }
  }

  function interpolateFromGrid(lon, lat) {
    if (!viewportGrid || !viewportGrid.grid) return null;
    
    const {lons, lats, grid} = viewportGrid;
    
    let lonIdx = -1, latIdx = -1;
    
    for (let i = 0; i < lons.length - 1; i++) {
      if (lon >= lons[i] && lon <= lons[i + 1]) {
        lonIdx = i;
        break;
      }
    }
    
    for (let i = 0; i < lats.length - 1; i++) {
      if (lat >= lats[i] && lat <= lats[i + 1]) {
        latIdx = i;
        break;
      }
    }
    
    if (lonIdx === -1 || latIdx === -1) return null;
    
    const v00 = grid[latIdx][lonIdx];
    const v10 = grid[latIdx][lonIdx + 1];
    const v01 = grid[latIdx + 1][lonIdx];
    const v11 = grid[latIdx + 1][lonIdx + 1];
    
    if (v00 === null && v10 === null && v01 === null && v11 === null) {
      return null;
    }
    
    if (v00 === null || v10 === null || v01 === null || v11 === null) {
      return v00 ?? v10 ?? v01 ?? v11;
    }
    
    const lonFrac = (lon - lons[lonIdx]) / (lons[lonIdx + 1] - lons[lonIdx]);
    const latFrac = (lat - lats[latIdx]) / (lats[latIdx + 1] - lats[latIdx]);
    
    const v0 = v00 * (1 - lonFrac) + v10 * lonFrac;
    const v1 = v01 * (1 - lonFrac) + v11 * lonFrac;
    const value = v0 * (1 - latFrac) + v1 * latFrac;
    
    return value;
  }

  function updateCursorReadout(lngLat, point) {
    if (map.getZoom() < CURSOR_ZMIN) {
      showCursorReadout(point.x, point.y, "");
      pendingCursorUpdate = null;
      return;
    }
    
    if (!tracksReady()) {
      showCursorReadout(point.x, point.y, "");
      pendingCursorUpdate = null;
      return;
    }
    
    if (!nearTrack(point, lngLat)) {
      showCursorReadout(point.x, point.y, "");
      pendingCursorUpdate = null;
      return;
    }
    
    if (gridFetchInProgress || shouldRefetchGrid()) {
      showCursorReadout(point.x, point.y, "Loading...");
      pendingCursorUpdate = {lngLat, point};
      
      if (shouldRefetchGrid()) {
        fetchViewportGrid();
      }
      return;
    }
    
    const value = interpolateFromGrid(lngLat.lng, lngLat.lat);
    
    if (value === null || value <= TRACE_INCHES) {
      showCursorReadout(point.x, point.y, "");
      pendingCursorUpdate = null;
      return;
    }
    
    showCursorReadout(point.x, point.y, value.toFixed(1) + " in");
    pendingCursorUpdate = null;
  }

  const debouncedGridFetch = debounce(fetchViewportGrid, 500);

  function onSelectionChange() {
    viewportGrid = null;
    lastGridBounds = null;
    lastGridKey = "";
    pendingCursorUpdate = null;
    fetchViewportGrid();
  }

  function shouldReadout(){
    const z=map.getZoom();
    const ok=z>=MIN_ZOOM_FOR_READOUT;
    if(!ok&&readoutsEnabled){
      readoutsEnabled=false;
      lastKey="";
      showCursorReadout(0,0,"");
    } else if(ok&&!readoutsEnabled){
      readoutsEnabled=true;
    }
    return ok;
  }

  map.on("mousemove", (e) => {
    if (cursorEl.style.display !== "none") {
      cursorEl.style.left = e.point.x + "px";
      cursorEl.style.top = e.point.y + "px";
    }
    
    if (!shouldReadout()) return;
    if (!tracksReady()) return;
    
    updateCursorReadout(e.lngLat, e.point);
  });

  map.on("mouseout", () => {
    showCursorReadout(0, 0, "");
    pendingCursorUpdate = null;
  });

  map.on("moveend", () => {
    debouncedGridFetch();
  });

  map.on("zoomend", () => {
    shouldReadout();
    if(map.getZoom()<CURSOR_ZMIN){lastKey="";showCursorReadout(0,0,"")}
    debouncedGridFetch();
    prefetchDebounced();
  });

  map.on("error", (e) => {
    const err = e.error;
    if (err && err.message && err.message.includes("404")) {
      console.warn("Tile not found:", err);
      return;
    }
    showErr("Map error:\n" + (err ? err.message : String(e)));
  });

  map.on("load",async()=>{
    try{
      renderLegend(24);

      const availPromise=loadAvailable();
      await addCnTracksVectorTiles();

      await availPromise;
      if(!available.length){showErr("No available days returned from /forecast/available_days");return}

      initSelectorsFromAvailable();
      setTilesForSelection();
      prefetchViewportTiles();
      setOpacity(parseFloat(OPACITY.value));
      shouldReadout();
      onSelectionChange();
    } catch(e){
      showErr("Init error:\n"+String(e));
    }
  });

  yearSel.addEventListener("change", () => {
    recomputeMonthOptions();
    recomputeDayOptions();
    setTilesForSelection();
    onSelectionChange();
  });
  
  monthSel.addEventListener("change", () => {
    recomputeDayOptions();
    setTilesForSelection();
    onSelectionChange();
  });
  
  daySel.addEventListener("change", () => {
    setTilesForSelection();
    onSelectionChange();
  });
  
  document.querySelectorAll('input[name="hours"]').forEach(el => 
    el.addEventListener("change", () => {
      setTilesForSelection();
      onSelectionChange();
    })
  );

  OPACITY.addEventListener("input",()=>setOpacity(parseFloat(OPACITY.value)));
})();
</script>

</body>
</html>
